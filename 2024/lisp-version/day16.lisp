(load "../../tools/tools.lisp")

(defparameter *input* (read-file-by-line "../inputs/day16.input"))
(defparameter *input-demo* (read-file-by-line "../inputs/day16_demo.input"))

(defun parse-input (input)
  (gen-aoc-map (loop for line in input
                     collect (concatenate 'list line))
               :ele-coops t :coop-ele t))

;; (defun walk-map (m)
;;   (let ((start (car (get-aoc-map-coops-of-ele m #\S))))
;;     (min )))

(defun is-legal-dir (dir next-dir)
  (cond ((eq dir next-dir) t)
        ((or (eq dir 'up) (eq dir 'down))
         (or (eq next-dir 'left) (eq next-dir 'right)))
        ((or (eq dir 'left) (eq dir 'right))
         (or (eq next-dir 'up) (eq next-dir 'down)))
        ((not dir) t)))

(defun one-step (m coop dir table)
  ;;(format t "coop: ~a, dir: ~a~%" coop dir)
  (setf (gethash coop table) t)
  (if (char= (get-aoc-map-ele m coop) #\E)
      (prog1 0
        ;; (let ((mm (clone-aoc-map m)))
        ;;   (loop for (c . v) in (alexandria:hash-table-alist table)
        ;;         do (set-aoc-map-ele mm c #\x))
        ;;   (format t "count: ~a~%" (length (alexandria:hash-table-alist table)))
        ;;   (print-raw-map mm))
        )
      (loop for (next dd) in (aoc-map-around-coop m coop :dir 'hor-ver :with-dir t)
            ;;do (format t "~a ~a ~a~%" (is-legal-dir dir dd) (not (char= (get-aoc-map-ele m next) #\#)) (not (equal next coop)))
            ;;do (format t "~a ~a ~a~%" (is-legal-dir dir dd) dir dd)
            when (and (is-legal-dir dir dd)
                      (not (char= (get-aoc-map-ele m next) #\#))
                      (not (equal next coop))
                      (not (gethash next table)))
              collect (if (or (eq dir dd) (not dir))
                          (let ((vv (one-step m next dd (alexandria:copy-hash-table table))))
                            (if vv (1+ vv) nil))
                          (let ((vv (one-step m next dd (alexandria:copy-hash-table table))))
                            (if vv (+ 1001 vv) nil)))
                into ll
            finally (progn (setf ll (remove nil ll))
                           (return (if ll (apply #'min ll) nil)))
            )))

;; (let ((m (parse-input *input-demo*)))
;;   (let ((start (car (get-aoc-map-coops-of-ele m #\S)))
;;         )
;;     (format t "~a~%" (one-step m start 'right (make-hash-table :test 'equal)))))

;; (defun copy-table (table)
;;   (let ((new-table (make-hash-table
;;                     :test (hash-table-test table)
;;                     :size (hash-table-size table))))
;;     (maphash #'(lambda(key value)
;;                  (setf (gethash key new-table) value))
;;              table)
;;     new-table))

(defun next-steps (coop dir)
  (let (offsets)
    (setf offsets
          (cond ((eq dir 'right)
                 '(((-1 0) up) ((1 0) down) ((0 1) right)))
                ((eq dir 'left)
                 '(((-1 0) up) ((1 0) down) ((0 -1) left)))
                ((eq dir 'up)
                 '(((0 -1) left) ((0 1) right) ((-1 0) up)))
                ((eq dir 'down)
                 '(((0 -1) left) ((0 1) right) ((1 0) down)))))
    (loop for (o dir) in offsets
          collect (list (mapcar #'+ o coop) dir))))

(defun dijkstra (m start)
  (let ((distance-table (make-hash-table :test 'equal))
        (visited (make-hash-set)))
    (setf (gethash start distance-table) 0)
    (do* (;; (coop dir)
          (this start) 
          ;; (coop dir cost)
          (next-round (make-instance 'cl-heap:binary-heap
                                     :sort-fun #'<
                                     :key #'third))
          (this-to-start-value (gethash this distance-table)
                               (gethash this distance-table))
          )
         ((equal (get-aoc-map-ele m (first this)) #\E)
          (gethash this distance-table))
      ;;(format t "this is ~a, heap is ~a~%" this (slot-value next-round 'cl-heap::data))
      (if (set-get visited this)
          nil
          (loop for (next next-dir) in (next-steps (first this) (second this))
                unless (equal (get-aoc-map-ele m next) #\#)
                  unless (set-get visited (list next next-dir))
                    do (let ((cost (if (eq next-dir (second this)) 1 1001)))
                         (if (or (not (gethash (list next next-dir) distance-table))
                                 (> (gethash (list next next-dir) distance-table) (+ this-to-start-value cost)))
                             (progn (setf (gethash (list next next-dir) distance-table)
                                          (+ this-to-start-value cost))
                                    (cl-heap:add-to-heap next-round (list next next-dir (+ this-to-start-value cost))))))
                ))
      ;;(format t "after heap is:~a~%" (slot-value next-round 'cl-heap::data))
      (set-insert visited this)
      (setf this (subseq (cl-heap:pop-heap next-round) 0 2))
      )))

;; (let ((m (parse-input *input-demo*)))
;;   (let ((start-coop (car (get-aoc-map-coops-of-ele m #\S)))
;;         )
;;     (format t "~a~%" (dijkstra m (list start-coop 'right)))))


(defun dijkstra-2 (m start)
  (let ((distance-table (make-hash-table :test 'equal))
        ;;(visited (make-hash-set))
        )
    (setf (gethash (subseq start 0 2) distance-table) 0)
    (do* (;; (coop dir cost all-path)
          (this start) 
          ;; (coop dir cost all-path)
          (next-round (make-instance 'cl-heap:binary-heap
                                     :sort-fun #'<
                                     :key #'third))
          ;; (this-to-start-value (gethash (subseq this 0 2) distance-table)
          ;;                      (if this (gethash (subseq this 0 2) distance-table)))
          (all-paths)
          )
         ((not this)
          all-paths)
      ;;(format t "this is ~a, heap is ~a~%" this (slot-value next-round 'cl-heap::data))
      (if  (equal (get-aoc-map-ele m (first this)) #\E)
           (push this all-paths)
           (progn
             (if (member (first this) (butlast (fourth this)) :test 'equal)
                 nil
                 (loop for (next next-dir) in (next-steps (first this) (second this))
                       unless (equal (get-aoc-map-ele m next) #\#)
                         unless (member (first this) (butlast (fourth this)) :test 'equal)
                           do (let ((cost (if (eq next-dir (second this)) 1 1001)))
                                (progn
                                  ;; (setf (gethash (list next next-dir) distance-table)
                                  ;;       (+ this-to-start-value cost))
                                  (cl-heap:add-to-heap next-round
                                                       (list next
                                                             next-dir
                                                             (+ (third this) cost)
                                                             (append (fourth this) (list next))))))
                       ))
             ;;(format t "after heap is:~a~%" (slot-value next-round 'cl-heap::data))
             ;;(set-insert visited (subseq this 0 2))
             ))
      (setf this (cl-heap:pop-heap next-round))
      )))


(defun day15-2 (input)
  (let ((m (parse-input input)))
    (let ((start-coop (car (get-aoc-map-coops-of-ele m #\S)))
          )
      (let ((result (dijkstra-2 m (list start-coop 'right 0 (list start-coop))))
            (steps (dijkstra m (list start-coop 'right))))
        ;;(format t "result: ~a~%" result)
        (format t "steps: ~a~%" steps)
        (let ((all-points (remove-duplicates (loop for r in result
                                                   when (= steps (third r))
                                                     append (fourth r))
                                             :test 'equal)))
          ;;(format t "points: ~a~%" all-points)
          (length all-points))
      
        ;; (loop for c in (remove-duplicates (loop for r in result append r))
        ;;       do (set-aoc-map-ele m c #\O))
        ;; (loop for c in '((15 1) (14 1) (13 1) (12 1) (11 1) (10 1) (9 1) (8 1) (7 1) (6 1)
        ;;                  (5 1) (5 2) (5 3) (6 3) (7 3) (8 3) (9 3) (10 3) (11 3) (12 3)
        ;;                  (13 3) (14 3) (15 3) (15 4) (15 5) (14 5) (13 5) (13 6) (13 7)
        ;;                  (13 8) (13 9) (13 10) (13 11) (12 11) (11 11) (11 12) (11 13)
        ;;                  (10 13) (9 13) (9 14) (9 15) (8 15) (7 15) (6 15) (5 15) (4 15)
        ;;                  (3 15) (2 15) (1 15))
        ;;       do (set-aoc-map-ele m c #\O))

        ;; (loop for c in ' ((15 1) (14 1) (13 1) (12 1) (11 1) (10 1) (9 1) (8 1) (7 1) (6 1)
        ;;                   (5 1) (5 2) (5 3) (6 3) (7 3) (8 3) (9 3) (10 3) (11 3) (12 3)
        ;;                   (13 3) (14 3) (15 3) (15 4) (15 5) (14 5) (13 5) (12 5) (11 5)
        ;;                   (11 6) (11 7) (10 7) (9 7) (9 8) (9 9) (8 9) (7 9) (6 9) (5 9)
        ;;                   (5 10) (5 11) (5 12) (5 13) (4 13) (3 13) (2 13) (1 13) (1 14)
        ;;                   (1 15))
        ;;       do (set-aoc-map-ele m c #\O))
      
        ;;(print-raw-map m)
        ))))
