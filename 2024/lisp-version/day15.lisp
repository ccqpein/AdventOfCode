(load "../../tools/tools.lisp")

(defparameter *input* (read-file-by-line "../inputs/day15.input"))
(defparameter *input-demo* (read-file-by-line "../inputs/day15_demo.input"))

(defun parse-input (input)
  (let ((input (split-sequence:split-sequence-if (lambda (l) (string= l ""))
                                                 input)))
    (values (gen-aoc-map (loop for l in (first input)
                               collect (concatenate 'list l))
                         :ele-coops t
                         :coop-ele t)
            (loop for l in (second input)
                  append (concatenate 'list l)))))

(defun set-step (map coop target)
  (set-aoc-map-ele map target (get-aoc-map-ele map coop))
  (set-aoc-map-ele map coop #\.))

(defun one-move (map this-coop command deep)
  ;;(format t "~a, ~a, ~a~%" this-coop command deep)
  (if (zerop deep) (return-from one-move (values nil this-coop)))
  (let ((offset (cond ((char= #\< command) '(0 -1))
                      ((char= #\> command) '(0 1))
                      ((char= #\v command) '(1 0))
                      ((char= #\^ command) '(-1 0)))))
    (let ((target (mapcar #'+ this-coop offset)))
      (cond ((char= (get-aoc-map-ele map target) #\.)
             (progn (set-step map this-coop (mapcar #'+ this-coop offset))
                    (values t target)))
            ((char= (get-aoc-map-ele map target) #\#)
             (values nil this-coop))
            (t (if (one-move map target command (1- deep))
                   (progn (set-step map this-coop (mapcar #'+ this-coop offset))
                          (values t target))
                   (values nil this-coop)))))))

(defun day15 (&optional (input *input*))
  (multiple-value-bind (m commands)
      (parse-input input)
    (let ((coop (car (get-aoc-map-coops-of-ele m #\@))))
      (loop for comm in commands
            do (setf coop (second (multiple-value-list (one-move m coop comm (get-aoc-map-cols-len m))))))
      (loop for (r c) in (get-aoc-map-coops-of-ele m #\O) sum (+ (* 100 r) c)))))

(defun parse-input-2 (input)
  (let ((input (split-sequence:split-sequence-if (lambda (l) (string= l "")) input)))
    (values (gen-aoc-map (loop for l in (first input)
                               collect (loop for c in (concatenate 'list l)
                                             if (char= c #\@) append (list #\@ #\.)
                                               else if (char= c #\O) append (list #\[ #\])
                                                      else append (list c c)))
                         :ele-coops t
                         :coop-ele t)
            (loop for l in (second input) append (concatenate 'list l)))))

(defun one-move-2 (map this-coop command)
  (let ((offset (cond ((char= #\< command) '(0 -1))
                      ((char= #\> command) '(0 1))
                      ((char= #\v command) '(1 0))
                      ((char= #\^ command) '(-1 0)))))
    (let ((target (mapcar #'+ this-coop offset)))
      (cond ((char= (get-aoc-map-ele map this-coop) #\.)
             (values t this-coop))
            ((char= (get-aoc-map-ele map this-coop) #\#)
             (values nil this-coop))
            ((and (or (char= (get-aoc-map-ele map this-coop) #\])
                      (char= (get-aoc-map-ele map this-coop) #\[))
                  (or (char= command #\^) (char= command #\v)))
             (if (char= (get-aoc-map-ele map this-coop) #\])
                 (if (and (one-move-2 map target command)
                          (one-move-2 map (mapcar #'+ target '(0 -1)) command))
                     (progn (set-step map this-coop target)
                            (set-step map (mapcar #'+ this-coop '(0 -1)) (mapcar #'+ target '(0 -1)))
                            (values t target))
                     (values nil this-coop))
                 (if (and (one-move-2 map target command)
                          (one-move-2 map (mapcar #'+ target '(0 1)) command))
                     (progn (set-step map this-coop target)
                            (set-step map (mapcar #'+ this-coop '(0 1)) (mapcar #'+ target '(0 1)))
                            (values t target))
                     (values nil this-coop))))
            (t(if (one-move-2 map target command)
                  (progn (set-step map this-coop target)
                         (values t target))
                  (values nil this-coop)))))))

(defun pre-check (map this-coop command)
  (let ((offset (cond ((char= #\< command) '(0 -1))
                      ((char= #\> command) '(0 1))
                      ((char= #\v command) '(1 0))
                      ((char= #\^ command) '(-1 0)))))
    (let ((target (mapcar #'+ this-coop offset)))
      (cond ((char= (get-aoc-map-ele map target) #\.) t)
            ((char= (get-aoc-map-ele map target) #\#) nil)
            ((and (or (char= (get-aoc-map-ele map target) #\])
                      (char= (get-aoc-map-ele map target) #\[))
                  (or (char= command #\^) (char= command #\v)))
             (if (char= (get-aoc-map-ele map target) #\])
                 (and (pre-check map target command)
                      (pre-check map (mapcar #'+ target '(0 -1)) command))
                 (and (pre-check map target command)
                      (pre-check map (mapcar #'+ target '(0 1)) command))))
            (t (pre-check map target command))))))

(defun day15-2 (&optional (input *input*))
  (multiple-value-bind (m commands)
      (parse-input-2 input)
    (let ((coop (car (get-aoc-map-coops-of-ele m #\@))))
      (print-raw-map m)
      (loop for comm in commands
            do (setf coop (second (multiple-value-list
                                   (if (pre-check m coop comm) (one-move-2 m coop comm) (values t coop))))))
      (print-raw-map m)
      (loop for (r c) in (get-aoc-map-coops-of-ele m #\[)
            sum (+ (* 100 r) c)))))

;; (multiple-value-bind (m commands)
;;     (parse-input-2 *input*)
;;   (let ((coop (car (get-aoc-map-coops-of-ele m #\@))))
;;     (print-raw-map m)
;;     (with-open-file (s #P"/Users/ccQ/Desktop/day15.output" :direction :output :if-exists :overwrite)
;;       ;;(format s "~{~{~a~}~%~}~%" (amap-raw-map m))
;;       (loop for comm in commands
;;             do ;;(format t "~a~%" comm)
;;                (setf coop (second (multiple-value-list (one-move-2 m coop comm))))
;;                ;;(set-aoc-map-ele m coop comm)
;;                ;;(print-raw-map m)
;;                (cond ((char= comm #\^)
;;                       (format s "After moving UP~%"))
;;                      ((char= comm #\v)
;;                       (format s "After moving DOWN~%"))
;;                      ((char= comm #\>)
;;                       (format s "After moving RIGHT~%"))
;;                      ((char= comm #\<)
;;                       (format s "After moving LEFT~%")))
;;                (format s "~%~{~{~a~}~%~}" (amap-raw-map m))
;;                ;;(read-line)
;;             )
;;       ;;(format s "~{~{~a~}~%~}~%" (amap-raw-map m))
;;       )
;;     (print-raw-map m)
;;     (loop for (r c) in (get-aoc-map-coops-of-ele m #\[)
;;           ;;do (format t "~a ~a~%" r c)
;;           sum (+ (* 100 r) c))
;;     ))
